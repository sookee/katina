=#top AFW Документация

* [#files Общие принципы]
* [#uri Разбор адреса]
* [#controller Контроллеры]
* [#model Модели]
* [#db Работа с базами данных]
* [#cache Кэш]
* [#file Обработка файлов и изображений]
* [#utils Утилиты]
** [#utilDebugLog Вывод отладочной информации]
** [#utilSession Сессии]
** [#utilUtils Дополнительные функции]
** [#utilParser Парсер]
* [#models Базовые модели]
** [#modelSettings Настройки]
** [#modelSupervisor Администратор]
** [#modelUser Пользователь]
** [#modelStatistics Статистика]
** [#modelMap Карта]
** [#modelBasket Корзина]
* [#controllers Базовые контроллеры]
** [#controllerLayout Макет]
** [#controllerSimpleList Простой список]
** [#controllerPaginator Страницы]
** [#controllerForm Форма]



==#intro Введение

Этот документ - документация к веб-фреймворку AFW(AFW FrameWork). Данный фреймворк предназначен как для начинающих веб-разработчиков, которые хотят научиться создавать свои проекты с нуля, так и для опытных, желающих полностью контролировать процесс загрузки страниц и работу проекта в целом, не допуская никаких лишних действий со стороны фреймворка.

В данный момент документация весьма краткая, со временем будет дополняться.

[https://github.com/Aequiternus/afw Исходный код] [http://inmemo.net/project/afw Ошибки и предложения]

Что необходимо знать, чтобы понимать о чем тут написано:

* [http://www.php.net/manual/ru/langref.php язык PHP]
* [http://ru.wikipedia.org/wiki/Model-View-Controller концепция MVC]

Используемые библиотеки PHP:

* [http://www.php.net/manual/ru/book.pdo.php PHP PDO] - работа с базами данных
* [http://www.php.net/manual/ru/book.apc.php PHP APC] - кэш
* [http://www.php.net/manual/ru/book.memcache.php PHP Memcache] - кэш
* [http://www.php.net/manual/ru/book.intl.php PHP Intl] - в данный момент только для транслитерации
* [http://www.php.net/manual/ru/book.gettext.php PHP Gettext] - поддержка многоязычности
* [http://php.net/manual/ru/book.image.php PHP GD] - обработка изображений
* [http://www.imagemagick.org/ ImageMagick] - обработка изображений



==#files Структура файлов

Структура папок строго соответствует [http://www.php.net/manual/ru/language.namespaces.rationale.php пространствам имен], которые фреймворк активно использует. В конфигурации каждого приложения должна быть определена функция автоматической загрузки классов. Расположение файлов классов зависит от конкретного проекта и определяется этой функцией. По умолчанию корневая папка классов и корневое пространство имен совпадает с корневой папкой приложения.

```
function __autoload($class)
{
    require str_replace('\\', '/', $class) . '.php';
}
```

Это позволяет забыть о том какие файлы необходимо подключить с помощью `include` или `require`, и в то же время при работе приложения всегда будут подключены только необходимые файлы.

Все файлы фреймворка расположены в папке и пространстве имен `afw`.

Фреймворк основан на распространенном и удобном для разработки веб-приложений шаблоне программирования MVC(Model-View-Controller, Модель-Представление-Контроллер). В связи с этим, в фреймворке существует два основных пространства имен: `m` для моделей и `c` для контроллеров, а также папка `v` для представлений (шаблонов).

Ресурсные файлы - те файлы которые используются на html-страницах: css, js, изображения и др. Располагаются эти файлы в папке `res`. Документация в папке `doc`, файлы локализации в папке `locale`. Классы, написанные сторонними разработчиками, расположены в папке `ext`.



==#uri Разбор адреса

Для разбора адреса предусмотрен специальный контроллер `afw\c\Uri`. С помощью метода `addPattern` можно задать регулярное выражение и соответствующую ему функцию-обработчик, аргументом которой являются [http://www.php.net/manual/ru/function.preg-match-all.php результаты поиска] регулярного выражения. Обработчик должен вернуть контроллер, описание работы которых будет ниже.

После установки всех необходимых адресов можно получить соответствующий текущему адресу контроллер с помощью метода `getController`, или сразу запустить отрисовку с помощью этого контроллера `renderController`.

```
$uri = afw\c\Uri::instance();

$uri->addPattern(
    '`^blog/post-(\d+)$`', # рег. выр. адреса записи в блоге, например /blog/post-123
    function ($matches)
    {
        $postId = $matches[1];              # получение номера записи в блоге
        $controller = new c\Post($postId);  # создание контроллера записи в блоге
        return $controller;
    }
);

$uri->renderController();
```

Обратите внимание, что контроллер `afw\c\Uri` автоматически убирает начальные и конечные слэши из адреса перед проверкой. Для получения преобразованного адреса используйте `afw\c\Uri::current()`.

Контроллер `afw\c\Uri` позволяет установить обработчик исключений, который будет вызван если ни один шаблон адреса не подошел, обработчик вернул не класс контроллера или в случае возникновения любого другого исключения. Аргументом обработчика в данном случае является исключение. Для отображения информации об исключении предусмотрен базовый контроллер `afw\c\Exception`.

```
$uri->setException(function($exception)
{
    return new afw\c\Exception($exception));
});
```

На ранних этапах создания приложения может оказаться очень полезным универсальный контроллер `afw\c\Uri::variable`, который просто вызывает у класса, указанного в первом аргументе, метод, указанный во втором аргументе, с параметрами переданными в третьем аргументе. Четвертым аргументом можно указать фильтр допустимых классов и методов в виде массива (значениями являются имена классов или подмассивы методов, в этом случае имя класса используется в качестве ключа). Ниже представлен самый простой пример регулярного выражения и обработчика для этого контроллера.

```
# namespace/class:method/arguments
# http://example.com/c/Post:update/123
# http://example.com/c/Photo:get/321
$uri->addPattern(
    '`^([\w/]+):(\w+)(/.*)?$`',
    function ($matches)
    {
        return afw\c\Uri::variable(
            '\\'.str_replace('/', '\\', $matches[1]),
            $matches[2],
            explode('/', trim(@$matches[3], '/')),
            [
                '\c\Post'  => ['insert', 'update', 'delete', 'get', 'getList'],
                '\c\Photo' => ['insert', 'update', 'delete', 'get', 'getList'],
            ]
        );
    }
);
```

Крайне не рекомендуется использовать контроллер `afw\c\Uri::variable` без фильтра.



==#controller Контроллеры

Базовый класс контроллеров `afw\c\Controller` очень прозрачен и представляет простой и гибкий инструмент работы с представлениями. Его функциональность можно разбить на три составляющие: подключение своих представлений, добавление дочерних контроллеров, обворачивание контроллером-макетом (layout).



=== Подключение представлений

Для подключения представления достаточно использовать метод `setViewFile` или `setView`. Аргументом для первого метода является путь к файлу представления (шаблону), а для второго может быть имя класса (`__CLASS__`) или метода (`__METHOD__`), который автоматически будет преобразован в соответствующий путь к файлу. Для второго метода принято заменять в пути папку (пространство имен) `c` на `v`.

```
namespace c;

class StaticPages
{
    static function help($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/help.php
        return $c;
    }

    static function faq($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/faq.php
        return $c;
    }
}
```

Можно установить несколько представлений подряд. В этом случае каждое последующее представление будет завернуто в предыдущее и будет вызываться на месте вызова `$this->contents()` предыдущего представления. Это очень удобно использовать при наследовании контроллера. Например у вас есть контроллер отвечающий за внешнее оформление страницы, и, наследуя его, вы пишете контроллер конкретной страницы. Тогда достаточно установить в конструкторе страницы новое представление после вызова родительского конструктора.

```
namespace c;

class ExampleLayout extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends ExampleLayout
{
    function __construct()
    {
        parent::construct();
        $this->setView(__CLASS__); # путь v/ExamplePage.php будет завернут в v/ExampleLayout.php
    }
}
```

```
<?php /* файл v/ExampleLayout.php */ /* @var $this c\ExampleLayout */ ?>
<html>
<!-- оформление сверху -->
<?php $this->contents() ?>
<!-- оформление снизу -->
</html>
```

```
<?php /* файл v/ExamplePage.php */ /* @var $this c\ExamplePage */ ?>
<h1>Hello World!</h1>
```

При отрисовке (вызове метода `render`) экземпляра класса `ExamplePage` получится следующий html-код.

```
<html>
<!-- оформление сверху -->
<h1>Hello World!</h1>
<!-- оформление снизу -->
</html>
```

Аналогичным образом можно установить новое представление до родительского конструктора, тогда представления будут вложены друг в друга с точностью до наоборот - представление родительского класса будет вложено в представление дочернего. Использовать данный подход можно если, например, у вас есть некоторые данные, которые нужно выводить в разном виде на экран и на печать.

```
namespace c;

class DataSheet extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/DataSheet.php
    }
}

class DataSheetPage extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на экран в v/DataSheetPage.php
        parent::construct();
    }
}

class DataSheetPrint extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на печать в v/DataSheetPrint.php
        parent::construct();
    }
}
```

Свободно используйте оба подхода в зависимости от конкретных задач и личных предпочтений.



=== Добавление дочерних контроллеров (`push`)

В контроллер можно добавить любые (не обязательно одного класса) дочерние контроллеры с помощью метода `push`. Все дочерние контроллеры будут отрисовываться в порядке добавления в месте вызова `$this->contents()` в конечном представлении.

```
namespace c;

class ExampleForm extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleForm.php

        $this->push(new InputText('login'));
        $this->push(new InputPassword('pass'));
    }
}

class InputText extends \afw\c\Controller
{
    public $name;

    function __construct($name)
    {
        $this->setView(__CLASS__); # путь: v/InputText.php
        $this->name = $name;
    }
}

class InputPassword extends \afw\c\Controller
{
    public $name;

    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/InputPassword.php
        $this->name = $name;
    }
}
```

```
<?php /* файл v/ExampleForm.php */ /* @var $this c\ExampleForm */ ?>
<form>
<h1>Example Form</h1>
<?php $this->contents() ?>
</form>
```

```
<?php /* файл v/InputText.php */ /* @var $this c\InputText */ ?>
<input type="text" name="<?= $this->name ?>" />
```

```
<?php /* файл v/InputPassword.php */ /* @var $this c\InputPassword */ ?>
<input type="password" name="<?= $this->name ?>" />
```

При отрисовке экземпляра класса `ExampleForm` получится следующий html-код.

```
<form>
<h1>Example Form</h1>
<input type="text" name="login" />
<input type="password" name="pass" />
</form>
```



=== Обворачивание контроллером (`wrap`)

Чтобы обвернуть представление контроллера, не обязательно использовать наследование, можно также воспользоваться методом `wrap`. Обратите внимание, что в данном случае, необходимо вызывать отрисовку (метод `render`) у исходного контроллера, а не у контроллера-макета, в который будет завернут исходный контроллер. Данный подход удобен при использовании уже готовых классов, когда наследование невозможно или не удобно.

```
namespace c;

class ExampleLayout extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExamplePage.php
    }
}

$page = new ExamplePage();
$page->wrap(new ExampleLayout());
$page->render();
```

Результат отрисовки будет такой же, как если бы `ExamplePage` наследовался от `ExampleLayout`.

Можно использовать несколько оберток подряд, в этом случае каждая последующая обертка будет обворачиваться вокруг предыдущей.



==#model Модели

Модели превращают сырые данные в целостные сущности, необходимые вашему приложению. Базовый класс модели `afw\m\Model` обладает очень малой функциональностью, которая тем не менее покрывает большую часть простых задач: статичные страницы, новостные ленты, комментарии, фотогаллереи - все это можно реализовать даже не наследуя и не расширяя базовый класс моделей.

Модель соответствует одной таблице базы данных. Для создания модели необходимо указать соединение и имя таблицы. Подробнее о работе с базами данных будет описано ниже.



=== Поля модели

Модель может содержать поля, которые добавляются с помощью метода `addField`. Полям модели можно добавить фильтры с помощью метода `addFilter` или одного из предопределенных методов-фильтров, которые будут использоваться каждый раз при сохранении данных. Фильтр представляет собой функцию с четырьмя аргументами:  значение, имя поля, массив всех сырых фильтруемых данных, массив всех отфильтрованных данных. Функция-фильтр должна вернуть отфильтрованное значение или выкинуть исключение. Существует специальное исключение `afw\m\ModelFilterSkip`, которое позволит пропустить фильтруемое значение, то есть оно не будет включено в массив отфильтрованных данных.

Также каждому полю модели можно установить контроллер поля формы с помощью метода `setFormField`, который по умолчанию будет использован в формах добавления и редактирования данных. Фреймворк содержит набор контроллеров соответствующий стандартным полям формы, получить их можно используя статические методы класса `afw\c\Form\Element`  Подробнее о формах будет написано ниже.

```
use \afw\c\Form\Element;

$m = new \afw\m\Model($db_conn, 'guestbook');

$m->addField('name')
    ->required()    # добавить фильтр, проверяющий что поле заполнено
    ->setFormField(Element::text('Имя*'));

$m->addField('email')
    ->email()       # добавить фильтр, проверяющий корректность адреса эл. почты
    ->setFormField(Element::text('E-mail'));

$m->addField('message')
    ->required()
    ->strip_tags()  # добавить фильтр, удаляющий все теги из текста
    # добавить произвольный фильтр
    ->addFilter(function example_filter($value, $name, $values, &$result)
        {
            # произвести произвольные преобразования, например trim
            $value = trim($value);

            # убрать из данных значение, если оно равно "skip_me"
            if ($value == 'skip_me')
            {
                throw new \afw\m\ModelFilterSkip();
            }

            # последний аргумент можно использовать для модификации других полей
            $result[$name . '_a2o'] = str_replace('a', 'o', value);

            return $value;
        }
    ->setFormField(Element::textarea('Сообщение*'));
```

Чтобы отфильтровать массив данных используется метод `filter`. Этот метод выполняет все фильтры и собирает все возникшие исключения в одно общее `afw\m\ModelFilterException`, которое можно использовать при обработке форм.

Если вы обеспокоены тем что ваши модели содержат много полей, но добавление полей и фильтров необходимо только для редактирования данных, которое происходит крайне редко, то можно воспользоваться методом `setFields`, аргументом которого является функция, которая добавляет все необходимые поля и фильтры. Этот метод вызывается при первом вызове метода `filter`. Таким образом создание полей и фильтров будет происходить только тогда, когда это действительно необходимо.

```
$m = new Model($db_conn, 'mytable');

$m->setFields(function($m)
{
    $m->addField('field1');
    ...
    $m->addField('field100500');
});
```



=== Фабрики моделей

Если вы обеспокоены тем что ваш проект содержит очень много моделей, но одновременно на странице используется только одна или несколько моделей, при этом создавать остальные модели совершенно не нужно. Чтобы не происходило создания не нужных в данный момент моделей, можно воспользоваться классом `afw\InstanceFactory`, пример ниже опишет его использование.

```
class M extends afw\InstanceFactory
{
    /**
     * @return afw\m\Model
     */
    static function guestbook()
    {
        return self::instance(__FUNCTION__, function(&$m)
        {
            $m = new afw\m\Model(Storage::main(), 'guestbook_table');
            $m->setFields(...);
        });
    }

    /**
     * @return afw\m\Model
     */
    static function blog()
    {
        return self::instance(__FUNCTION__, function(&$m)
        {
            $m = new afw\m\Model(Storage::main(), 'blog_table');
            $m->setFields(...);
        });
    }
}

$blog_post_123 = M::blog()->get(123);

```

Таким образом, доступ к вашим моделям будет осуществляться с помощью статических методов класса `M`, а сами модели будут созданы только при первом вызове соответствующего статического метода. Имя класса `M` может быть любым, а также ничто не мешает разбить модели на несколько классов-фабрик.



=== Доступ к данным

Не все модели обязательно работают с базой данных, например модель настроек `afw\m\Settings` хранит данные в файле и использует только поля и фильтры моделей. Специально для таких случаев модели разделены на два класса `afw\m\ModelWithFields`, содержащий функционал работы с полями, и наследуемый от него `afw\m\Model`, содержащий работу с базой данных. Класс `afw\m\Model` умеет также сохранять в своих полях ссылки на файлы и изображения и сохранять их в соответствующем месте на диске, подробнее об этом ниже.

Для сохранения и удаления данных моделей используются стандартные методы `insert`, `update` и `delete`. Метод `insert` возвращает установленный первичный ключ, если он не комплексный и генерируется автоматически.

Для получения данных по идентификатору используются методы `get` и `tryGet`, первый из них выкидывает исключение `afw\HttpException (404)` если данные не найдены, а второй вместо этого просто вернет `null`. Поле используемое в качестве первичного ключа, или массив с именами полей, если первичный ключ комплексный, задается в свойстве модели `pkey`, которое по умолчанию установлено `'id'`.

Чтобы произвести произвольную выборку данных, используются методы `db` и `_db`. Разделение на эти методы условное: в то время как первый метод может накладывать дополнительные условия на все выборки, второй предназначен для внутреннего использования и устанавливает только необходимый набор данных для выборки - имя таблицы, первичный ключ и кэш. Обратите внимание, что в методах `insert`, `update` и `delete` используется именно второй метод `_db`. В базовом классе `afw\m\Model` эти методы являются синонимами, условное разделение предназначено только для наследуемых классов. Подробнее о выборках и работе с базами данных будет описано ниже.

Часто при выводе списков необходима постраничная разбивка. Для получения количества страниц есть метод `pages`, его можно использовать вместе с контроллером `afw\c\Paginator`, описание которого будет ниже. Этот метод совершит дополнительный запрос в базу данных для подсчета количества записей соответствующих предыдущему запросу. Если в предыдущем запросе был установлен `offset`, то есть производилась выборка не первой страницы, и результат запроса был пуст, то метод `pages` выкинет исключение `afw\HttpException (404)`. Если вам не нужно знать количество страниц, но необходимо проверить что результат запроса не пуст на не первой странице, то используйте метод `checkPage`.

```
$page = 2;
$blog_posts = M::blog()->db()
    ->limit(10)
    ->page($page);

$paginator = new afw\c\Paginator(M::blog()->pages(), $page);
```


=== Связывание моделей

Еще одной важной особенностью моделей является возможность их связывать. Аналогично тому как связываются таблицы в базе данных с помощью внешних ключей, модели связываются с помощь метода `addReference`. Первым аргументом передается модель, с которой производится связывание, вторым аргументом идет имя массива моделей, со стороны модели, на которую мы ссылаемся, третьим - название модели на которую установлена ссылка со стороны текущей модели, четвертым не обязательным аргументом является имя ключевого поля текущей модели в базе данных, если четвертый аргумен не указан, то в качестве ключевого поля используется третий аргумент.

```
$user_model     = new afw\m\Model(Storage::main(), 'user_table');
$comment_model  = new afw\m\Model(Storage::main(), 'comment_table');

$comment_model->addReference($user_model, 'comments', 'user', 'user_id');
```

Когда модели связаны, становится легко выбрать связанные данные с помощью методов `references` и `referrers`. Первым аргументом этих методов является массив уже имеющихся данных, для которых необходимо выбрать связанные, а вторым указывается название этих данных относительно модели, в которой производится выборка. Метод `references` позволит выбрать данные, ссылающиеся на данные указанные в первом аргументе. Метод `referrers`, наоборот, выберет данные, на которые ссылаются данные первого аргумента. Второй аргумент не обязателен, и если его не указать, то будет произведена выборка из всех существующих связанных моделей. Продолжим код предыдущего примера.

```
# выбрать страницу комментариев из базы
$comments = $comment_model->db()
    ->limit(10)
    ->page(1);

# выбрать пользователей оставивших комментарии
$users = $user_model->referrers($comments, 'comments')->all();
```

Не обязательно сохранять пользователей в переменную `$users`, так как в массиве `$comments` каждому комментарию будет добавлен элемент с ключем `user` и значением содержащим данные соответствующего пользователя. Сохранять переменную `$users` есть смысл, если необходимо сделать выборку связанных данных относительно массива `$users`, например выбрать к каким группам принадлежат пользователи, в этом случае группы будут добавлены и к элементам массива `$users` и к соответствующим элементам массива `$comments`, то есть все данные сохраняются в массивах по ссылкам.

Далее пример использования `references`.

```
# выбрать пользователя с идентификатором 1
$user = $user_model->get(1);

# выбрать все комментарии пользователя
$comments = $comment_model->references($user, 'user')->all();
```

Аналогично предыдущему примеру, не обязательно сохранять комментарии в переменную `$comments`, так как в `$user` будет добавлен элемент с ключем `comments` и значением содержащим массив всех соответствующих комментариев.

Обратите внимание, что в первом примере в `referrers` был передан массив комментариев, а во втором в `references` был передан только один пользователь, но обе функции `references` и `referrers` обрабатывают оба варианта передачи данных.



==#db Работа с базами данных

Для работы с базами данных предусмотрен класс `afw\APDO`. Он назван так не случайно, и является прямым наследником [http://www.php.net/manual/ru/book.pdo.php `PDO`]. Этот класс немного расширяет возможности `PDO` и упрощает обычную работу с БД, в то же время не ограничивая спектр возможностей родительского класса `PDO`.

Соединение с БД происходит при вызове метода `connect`, а не в конструкторе как у `PDO`, и вызывается автоматически при первом запросе в базу, если вы используете методы класса `afw\APDO`. Но если вы сначала используете методы родительского класса `PDO`, то `connect` необходимо вызвать вручную. Таким образом вы можете быть уверены в том что соединение не будет установлено, если в этом нет необходимости. Например когда на некоторой странице вообще не предусмотрено запросов в БД, или когда все запросы есть кэше, речь о котором будет ниже.

Чтобы произвести самый простой запрос в БД - выбрать все записи из таблицы, необходимо указать имя таблицы с помощью метода `table` и вызвать метод `all`. В результате получим массив всех строк таблицы, аналогично вызову `PDOStatement::fetchAll()`.

```
$db = new afw\APDO('mysql:host=localhost;dbname=test', 'user', 'password');
$result = $db
    ->table('test_table')
    ->all(); # SELECT * FROM test_table
```



==#cache Кэш



==#file Обработка файлов и изображений
