=#top AFW Документация

* [#files Структура файлов]
* [#uri Разбор адреса]
* [#controller Контроллеры]
* [#model Модели]
* [#db Работа с базами данных]
* [#cache Кэш]
* [#file Работа с файлами и изображениями]
* [#utils Утилиты]
** [#utilDebugLog Вывод отладочной информации]
** [#utilSession Сессии]
** [#utilUtils Дополнительные функции]
** [#utilParser Парсер]
* [#models Базовые модели]
** [#modelSettings Настройки]
** [#modelSupervisor Администратор]
** [#modelUser Пользователь]
** [#modelStatistics Статистика]
** [#modelMap Карта]
** [#modelBasket Корзина]
* [#controllers Базовые контроллеры]
** [#controllerLayout Макет]
** [#controllerSimpleList Простой список]
** [#controllerPaginator Страницы]
** [#controllerForm Форма]



==#intro Введение

Этот документ - документация к веб-фреймворку AFW(AFW FrameWork). Данный фреймворк предназначен как для начинающих веб-разработчиков, которые хотят научиться создавать свои проекты с нуля, так и для опытных, желающих полностью контролировать процесс загрузки страниц и работу проекта в целом, не допуская никаких лишних действий со стороны фреймворка.

В данный момент документация весьма краткая, со временем будет дополняться.

[https://github.com/Aequiternus/afw Исходный код]
[http://inmemo.net/project/afw Ошибки и предложения]

Что необходимо знать, чтобы понимать о чем тут написано:

* [http://www.php.net/manual/ru/langref.php язык PHP]
* [http://ru.wikipedia.org/wiki/Model-View-Controller концепция MVC]
* базовый синтаксис [http://ru.wikipedia.org/wiki/SQL SQL]

Необходим PHP версии не ниже 5.4.
Используемые библиотеки PHP:

* [http://www.php.net/manual/ru/book.pdo.php PHP PDO] - работа с базами данных
* [http://www.php.net/manual/ru/book.apc.php PHP APC] - кэш
* [http://www.php.net/manual/ru/book.memcache.php PHP Memcache] - кэш
* [http://www.php.net/manual/ru/book.intl.php PHP Intl] - в данный момент только для транслитерации
* [http://www.php.net/manual/ru/book.gettext.php PHP Gettext] - поддержка многоязычности
* [http://php.net/manual/ru/book.image.php PHP GD] - обработка изображений
* [http://www.imagemagick.org/ ImageMagick] - обработка изображений



==#files Структура файлов

Структура папок строго соответствует [http://www.php.net/manual/ru/language.namespaces.rationale.php пространствам имен], которые фреймворк активно использует. В конфигурации каждого приложения должна быть определена функция автоматической загрузки классов. Расположение файлов классов зависит от конкретного проекта и определяется этой функцией. По умолчанию корневая папка классов и корневое пространство имен совпадает с корневой папкой приложения.

```
function __autoload($class)
{
    require str_replace('\\', '/', $class) . '.php';
}
```

Это позволяет забыть о том какие файлы необходимо подключить с помощью `include` или `require`, и в то же время при работе приложения всегда будут подключены только необходимые файлы.

Все файлы фреймворка расположены в папке и пространстве имен `afw`.

Фреймворк основан на распространенном и удобном для разработки веб-приложений шаблоне программирования MVC(Model-View-Controller, Модель-Представление-Контроллер). В связи с этим, в фреймворке существует два основных пространства имен: `m` для моделей и `c` для контроллеров, а также папка `v` для представлений (шаблонов).

Ресурсные файлы - те файлы которые используются на html-страницах: css, js, изображения и др. Располагаются эти файлы в папке `res`. Документация в папке `doc`, файлы локализации в папке `locale`. Классы, написанные сторонними разработчиками, расположены в папке `ext`.



==#uri Разбор адреса

Для разбора адреса предусмотрен специальный контроллер `afw\c\Uri`. С помощью метода `addPattern` можно задать регулярное выражение и соответствующую ему функцию-обработчик, аргументом которой являются [http://www.php.net/manual/ru/function.preg-match-all.php результаты поиска] регулярного выражения. Обработчик должен вернуть контроллер, описание работы которых будет ниже.

После установки всех необходимых адресов можно получить соответствующий текущему адресу контроллер с помощью метода `getController`, или сразу запустить отрисовку с помощью этого контроллера `renderController`.

```
$uri = afw\c\Uri::instance();

$uri->addPattern(
    '`^blog/post-(\d+)$`', # рег. выр. адреса записи в блоге, например /blog/post-123
    function ($matches)
    {
        $postId = $matches[1];              # получение номера записи в блоге
        $controller = new c\Post($postId);  # создание контроллера записи в блоге
        return $controller;
    }
);

$uri->renderController();
```

Обратите внимание, что контроллер `afw\c\Uri` автоматически убирает начальные и конечные слэши из адреса перед проверкой. Для получения преобразованного адреса используйте `afw\c\Uri::current()`.

Контроллер `afw\c\Uri` позволяет установить обработчик исключений, который будет вызван если ни один шаблон адреса не подошел, обработчик вернул не класс контроллера или в случае возникновения любого другого исключения. Аргументом обработчика в данном случае является исключение. Для отображения информации об исключении предусмотрен базовый контроллер `afw\c\Exception`.

```
$uri->setException(function($exception)
{
    return new afw\c\Exception($exception));
});
```

На ранних этапах создания приложения может оказаться очень полезным универсальный контроллер `afw\c\Uri::variable`, который просто вызывает у класса, указанного в первом аргументе, метод, указанный во втором аргументе, с параметрами переданными в третьем аргументе. Четвертым аргументом можно указать фильтр допустимых классов и методов в виде массива (значениями являются имена классов или подмассивы методов, в этом случае имя класса используется в качестве ключа). Ниже представлен самый простой пример регулярного выражения и обработчика для этого контроллера.

```
# namespace/class:method/arguments
# http://example.com/c/Post:update/123
# http://example.com/c/Photo:get/321
$uri->addPattern(
    '`^([\w/]+):(\w+)(/.*)?$`',
    function ($matches)
    {
        return afw\c\Uri::variable(
            '\\'.str_replace('/', '\\', $matches[1]),
            $matches[2],
            explode('/', trim(@$matches[3], '/')),
            [
                '\c\Post'  => ['insert', 'update', 'delete', 'get', 'getList'],
                '\c\Photo' => ['insert', 'update', 'delete', 'get', 'getList'],
            ]
        );
    }
);
```

Крайне не рекомендуется использовать контроллер `afw\c\Uri::variable` без фильтра.



==#controller Контроллеры

Базовый класс контроллеров `afw\c\Controller` очень прозрачен и представляет простой и гибкий инструмент работы с представлениями. Его функциональность можно разбить на три составляющие: подключение своих представлений, добавление дочерних контроллеров, обворачивание контроллером-макетом (layout).



=== Подключение представлений

Для подключения представления достаточно использовать метод `setViewFile` или `setView`. Аргументом для первого метода является путь к файлу представления (шаблону), а для второго может быть имя класса (`__CLASS__`) или метода (`__METHOD__`), который автоматически будет преобразован в соответствующий путь к файлу. Для второго метода принято заменять в пути папку (пространство имен) `c` на `v`.

```
namespace c;

class StaticPages
{
    static function help($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/help.php
        return $c;
    }

    static function faq($id)
    {
        $c = new \afw\c\Controller($id);
        $c->setView(__METHOD__); # путь: v/StaticPages/faq.php
        return $c;
    }
}
```

Можно установить несколько представлений подряд. В этом случае каждое последующее представление будет завернуто в предыдущее и будет вызываться на месте вызова `$this->contents()` предыдущего представления. Это очень удобно использовать при наследовании контроллера. Например у вас есть контроллер отвечающий за внешнее оформление страницы, и, наследуя его, вы пишете контроллер конкретной страницы. Тогда достаточно установить в конструкторе страницы новое представление после вызова родительского конструктора.

```
namespace c;

class ExampleLayout extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends ExampleLayout
{
    function __construct()
    {
        parent::construct();
        $this->setView(__CLASS__); # путь v/ExamplePage.php будет завернут в v/ExampleLayout.php
    }
}
```

```
<?php /* файл v/ExampleLayout.php */ /* @var $this c\ExampleLayout */ ?>
<html>
<!-- оформление сверху -->
<?php $this->contents() ?>
<!-- оформление снизу -->
</html>
```

```
<?php /* файл v/ExamplePage.php */ /* @var $this c\ExamplePage */ ?>
<h1>Hello World!</h1>
```

При отрисовке (вызове метода `render`) экземпляра класса `ExamplePage` получится следующий html-код.

```
<html>
<!-- оформление сверху -->
<h1>Hello World!</h1>
<!-- оформление снизу -->
</html>
```

Аналогичным образом можно установить новое представление до родительского конструктора, тогда представления будут вложены друг в друга с точностью до наоборот - представление родительского класса будет вложено в представление дочернего. Использовать данный подход можно если, например, у вас есть некоторые данные, которые нужно выводить в разном виде на экран и на печать.

```
namespace c;

class DataSheet extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/DataSheet.php
    }
}

class DataSheetPage extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на экран в v/DataSheetPage.php
        parent::construct();
    }
}

class DataSheetPrint extends DataSheet
{
    function __construct()
    {
        $this->setView(__CLASS__); # обвернуть для вывода на печать в v/DataSheetPrint.php
        parent::construct();
    }
}
```

Свободно используйте оба подхода в зависимости от конкретных задач и личных предпочтений.



=== Добавление дочерних контроллеров (`push`)

В контроллер можно добавить любые (не обязательно одного класса) дочерние контроллеры с помощью метода `push`. Все дочерние контроллеры будут отрисовываться в порядке добавления в месте вызова `$this->contents()` в конечном представлении.

```
namespace c;

class ExampleForm extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleForm.php

        $this->push(new InputText('login'));
        $this->push(new InputPassword('pass'));
    }
}

class InputText extends \afw\c\Controller
{
    public $name;

    function __construct($name)
    {
        $this->setView(__CLASS__); # путь: v/InputText.php
        $this->name = $name;
    }
}

class InputPassword extends \afw\c\Controller
{
    public $name;

    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/InputPassword.php
        $this->name = $name;
    }
}
```

```
<?php /* файл v/ExampleForm.php */ /* @var $this c\ExampleForm */ ?>
<form>
<h1>Example Form</h1>
<?php $this->contents() ?>
</form>
```

```
<?php /* файл v/InputText.php */ /* @var $this c\InputText */ ?>
<input type="text" name="<?= $this->name ?>" />
```

```
<?php /* файл v/InputPassword.php */ /* @var $this c\InputPassword */ ?>
<input type="password" name="<?= $this->name ?>" />
```

При отрисовке экземпляра класса `ExampleForm` получится следующий html-код.

```
<form>
<h1>Example Form</h1>
<input type="text" name="login" />
<input type="password" name="pass" />
</form>
```



=== Обворачивание контроллером (`wrap`)

Чтобы обвернуть представление контроллера, не обязательно использовать наследование, можно также воспользоваться методом `wrap`. Обратите внимание, что в данном случае, необходимо вызывать отрисовку (метод `render`) у исходного контроллера, а не у контроллера-макета, в который будет завернут исходный контроллер. Данный подход удобен при использовании уже готовых классов, когда наследование невозможно или не удобно.

```
namespace c;

class ExampleLayout extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExampleLayout.php
    }
}

class ExamplePage extends \afw\c\Controller
{
    function __construct()
    {
        $this->setView(__CLASS__); # путь: v/ExamplePage.php
    }
}

$page = new ExamplePage();
$page->wrap(new ExampleLayout());
$page->render();
```

Результат отрисовки будет такой же, как если бы `ExamplePage` наследовался от `ExampleLayout`.

Можно использовать несколько оберток подряд, в этом случае каждая последующая обертка будет обворачиваться вокруг предыдущей.



==#model Модели

Модели превращают сырые данные в целостные сущности, необходимые вашему приложению. Базовый класс модели `afw\m\Model` обладает очень малой функциональностью, которая тем не менее покрывает большую часть простых задач: статичные страницы, новостные ленты, комментарии, фотогаллереи - все это можно реализовать даже не наследуя и не расширяя базовый класс моделей.

Модель соответствует одной таблице базы данных. Для создания модели необходимо указать соединение и имя таблицы. Подробнее о работе с базами данных будет описано ниже.



=== Поля модели

Модель может содержать поля, которые добавляются с помощью метода `addField`. Полям модели можно добавить фильтры с помощью метода `addFilter` или одного из предопределенных методов-фильтров, которые будут использоваться каждый раз при сохранении данных. Фильтр представляет собой функцию с четырьмя аргументами:  значение, имя поля, массив всех сырых фильтруемых данных, массив всех отфильтрованных данных. Функция-фильтр должна вернуть отфильтрованное значение или выкинуть исключение. Существует специальное исключение `afw\m\ModelFilterSkip`, которое позволит пропустить фильтруемое значение, то есть оно не будет включено в массив отфильтрованных данных.

Также каждому полю модели можно установить контроллер поля формы с помощью метода `setFormField`, который по умолчанию будет использован в формах добавления и редактирования данных. Фреймворк содержит набор контроллеров соответствующий стандартным полям формы, получить их можно используя статические методы класса `afw\c\Form\Element`  Подробнее о формах будет написано ниже.

```
use \afw\c\Form\Element;

$m = new \afw\m\Model($db_conn, 'guestbook');

$m->addField('name')
    ->required()    # добавить фильтр, проверяющий что поле заполнено
    ->setFormField(Element::text('Имя*'));

$m->addField('email')
    ->email()       # добавить фильтр, проверяющий корректность адреса эл. почты
    ->setFormField(Element::text('E-mail'));

$m->addField('message')
    ->required()
    ->strip_tags()  # добавить фильтр, удаляющий все теги из текста
    # добавить произвольный фильтр
    ->addFilter(function example_filter($value, $name, $values, &$result)
        {
            # произвести произвольные преобразования, например trim
            $value = trim($value);

            # убрать из данных значение, если оно равно "skip_me"
            if ($value == 'skip_me')
            {
                throw new \afw\m\ModelFilterSkip();
            }

            # последний аргумент можно использовать для модификации других полей
            $result[$name . '_foo2bar'] = str_replace('foo', 'bar', value);

            return $value;
        }
    ->setFormField(Element::textarea('Сообщение*'));
```

Чтобы отфильтровать массив данных используется метод `filter`. Этот метод выполняет все фильтры и собирает все возникшие исключения в одно общее `afw\m\ModelFilterException`, которое можно использовать при обработке форм.

Если вы обеспокоены тем что ваши модели содержат много полей, но добавление полей и фильтров необходимо только для редактирования данных, которое происходит крайне редко, то можно воспользоваться методом `setFields`, аргументом которого является функция, которая добавляет все необходимые поля и фильтры. Этот метод вызывается при первом вызове метода `filter`. Таким образом создание полей и фильтров будет происходить только тогда, когда это действительно необходимо.

```
$m = new Model($db_conn, 'test_table');

$m->setFields(function($m)
{
    $m->addField('field1');
    ...
    $m->addField('field100500');
});
```



=== Фабрики моделей

Если вы обеспокоены тем что ваш проект содержит очень много моделей, но одновременно на странице используется только одна или несколько моделей, при этом создавать остальные модели совершенно не нужно. Чтобы не происходило создания не нужных в данный момент моделей, можно воспользоваться классом `afw\InstanceFactory`, пример ниже опишет его использование.

```
class M extends afw\InstanceFactory
{
    /**
     * @return afw\m\Model
     */
    static function guestbook()
    {
        return self::instance(__FUNCTION__, function(&$m)
        {
            $m = new afw\m\Model(Storage::main(), 'guestbook_table');
            $m->setFields(...);
        });
    }

    /**
     * @return afw\m\Model
     */
    static function blog()
    {
        return self::instance(__FUNCTION__, function(&$m)
        {
            $m = new afw\m\Model(Storage::main(), 'blog_table');
            $m->setFields(...);
        });
    }
}

$blog_post_123 = M::blog()->get(123);

```

Таким образом, доступ к вашим моделям будет осуществляться с помощью статических методов класса `M`, а сами модели будут созданы только при первом вызове соответствующего статического метода. Имя класса `M` может быть любым, а также ничто не мешает разбить модели на несколько классов-фабрик.



=== Доступ к данным

Не все модели обязательно работают с базой данных, например модель настроек `afw\m\Settings` хранит данные в файле и использует только поля и фильтры моделей. Специально для таких случаев модели разделены на два класса `afw\m\ModelWithFields`, содержащий функционал работы с полями, и наследуемый от него `afw\m\Model`, содержащий работу с базой данных. Класс `afw\m\Model` умеет также сохранять в своих полях ссылки на файлы и изображения и сохранять их в соответствующем месте на диске, подробнее об этом ниже.

Для сохранения и удаления данных моделей используются стандартные методы `insert`, `update` и `delete`. Метод `insert` возвращает установленный первичный ключ, если он не комплексный и генерируется автоматически.

Для получения данных по идентификатору используются методы `get` и `tryGet`, первый из них выкидывает исключение `afw\HttpException (404)` если данные не найдены, а второй вместо этого просто вернет `null`. Поле используемое в качестве первичного ключа, или массив с именами полей, если первичный ключ комплексный, задается в свойстве модели `pkey`, которое по умолчанию установлено `'id'`.

Чтобы произвести произвольную выборку данных, используются методы `db` и `_db`. Разделение на эти методы условное: в то время как первый метод может накладывать дополнительные условия на все выборки, второй предназначен для внутреннего использования и устанавливает только необходимый набор данных для выборки - имя таблицы, первичный ключ и кэш. Обратите внимание, что в методах `insert`, `update` и `delete` используется именно второй метод `_db`. В базовом классе `afw\m\Model` эти методы являются синонимами, условное разделение предназначено только для наследуемых классов. Подробнее о выборках и работе с базами данных будет описано ниже.

Часто при выводе списков необходима постраничная разбивка. Для получения количества страниц есть метод `pages`, его можно использовать вместе с контроллером `afw\c\Paginator`, описание которого будет ниже. Этот метод совершит дополнительный запрос в базу данных для подсчета количества записей соответствующих предыдущему запросу. Если в предыдущем запросе был установлен `offset`, то есть производилась выборка не первой страницы, и результат запроса был пуст, то метод `pages` выкинет исключение `afw\HttpException (404)`. Если вам не нужно знать количество страниц, но необходимо проверить что результат запроса не пуст на не первой странице, то используйте метод `checkPage`.

```
$page = 2;
$blog_posts = M::blog()->db()
    ->limit(10)
    ->page($page);

$paginator = new afw\c\Paginator(M::blog()->pages(), $page);
```


=== Связывание моделей

Еще одной важной особенностью моделей является возможность их связывать. Аналогично тому как связываются таблицы в базе данных с помощью внешних ключей, модели связываются с помощь метода `addReference`. Первым аргументом передается модель, с которой производится связывание, вторым аргументом идет имя массива моделей, со стороны модели, на которую мы ссылаемся, третьим - название модели на которую установлена ссылка со стороны текущей модели, четвертым не обязательным аргументом является имя ключевого поля текущей модели в базе данных, если четвертый аргумен не указан, то в качестве ключевого поля используется третий аргумент.

```
$user_model     = new afw\m\Model(Storage::main(), 'user_table');
$comment_model  = new afw\m\Model(Storage::main(), 'comment_table');

$comment_model->addReference($user_model, 'comments', 'user', 'user_id');
```

Когда модели связаны, становится легко выбрать связанные данные с помощью методов `references` и `referrers`. Первым аргументом этих методов является массив уже имеющихся данных, для которых необходимо выбрать связанные, а вторым указывается название этих данных относительно модели, в которой производится выборка. Метод `references` позволит выбрать данные, ссылающиеся на данные указанные в первом аргументе. Метод `referrers`, наоборот, выберет данные, на которые ссылаются данные первого аргумента. Второй аргумент не обязателен, и если его не указать, то будет произведена выборка из всех существующих связанных моделей. Продолжим код предыдущего примера.

```
# выбрать страницу комментариев из базы
$comments = $comment_model->db()
    ->limit(10)
    ->page(1);

# выбрать пользователей оставивших комментарии
$users = $user_model->referrers($comments, 'comments')->all();
```

Не обязательно сохранять пользователей в переменную `$users`, так как в массиве `$comments` каждому комментарию будет добавлен элемент с ключем `user` и значением содержащим данные соответствующего пользователя. Сохранять переменную `$users` есть смысл, если необходимо сделать выборку связанных данных относительно массива `$users`, например выбрать к каким группам принадлежат пользователи, в этом случае группы будут добавлены и к элементам массива `$users` и к соответствующим элементам массива `$comments`, то есть все данные сохраняются в массивах по ссылкам.

Далее пример использования `references`.

```
# выбрать пользователя с идентификатором 1
$user = $user_model->get(1);

# выбрать все комментарии пользователя
$comments = $comment_model->references($user, 'user')->all();
```

Аналогично предыдущему примеру, не обязательно сохранять комментарии в переменную `$comments`, так как в `$user` будет добавлен элемент с ключем `comments` и значением содержащим массив всех соответствующих комментариев.

Обратите внимание, что в первом примере в `referrers` был передан массив комментариев, а во втором в `references` был передан только один пользователь, но обе функции `references` и `referrers` обрабатывают оба варианта передачи данных.



==#db Работа с базами данных

Для работы с базами данных предусмотрен класс `afw\APDO`. Он назван так не случайно, и является прямым наследником [http://www.php.net/manual/ru/book.pdo.php `PDO`]. Этот класс немного расширяет возможности `PDO` и упрощает обычную работу с БД, в то же время не ограничивая спектр возможностей родительского класса `PDO`.

Соединение с БД происходит при вызове метода `connect`, а не в конструкторе как у `PDO`, и вызывается автоматически при первом запросе в базу, если вы используете методы класса `afw\APDO`. Но если вы сначала используете методы родительского класса `PDO`, то `connect` необходимо вызвать вручную. Таким образом вы можете быть уверены в том что соединение не будет установлено, если в этом нет необходимости. Например когда на некоторой странице вообще не предусмотрено запросов в БД, или когда все запросы есть кэше, речь о котором будет ниже.

Метод `connected` позволяет определить, было ли установлено соединение с БД.

Рекомендуется использовать фабрики для соединений с БД, аналогично тому как это было описано в работе с моделями.

```
class Storage extends afw\InstanceFactory
{
    /**
     * @return afw\APDO
     */
    static function main()
    {
        return self::instance(__FUNCTION__, function(&$db)
        {
            $db = new afw\APDO('mysql:host=' . Config::dbHost . ';dbname=' . Config::dbName,
                Config::dbUser, Config::dbPass,
                [
                    \PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES "utf8"',
                    \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION
                ]
            );
        });
    }
}
```



=== Выборка данных

Чтобы произвести самый простой запрос в БД - выбрать все записи из таблицы, необходимо указать имя таблицы с помощью метода `table` и вызвать метод `all`. В результате получим массив всех строк таблицы, аналогично вызову `PDOStatement::fetchAll()`.

```
$result = Storage::main()
    ->table('test_table')
    ->all(); # SELECT * FROM test_table
```

Если необходимо выбрать только некоторые поля - используйте метод `fields`, аргументом которого может быть строка с перечислением полей как в SQL, или массив имен полей.

Для добавления условия используйте метод `where`, первым аргументом которого будет строка с SQL-условиями, а вторым - массив аргументов. Аналогично тому как если бы вы использовали `PDO::prepare` и `PDOStatement::execute`. Одновременно можно добавить несколько условий, они будут соединены через `AND`. Если вы хотите соединить условия через `OR` - используйте метод `orWhere` или установите третий параметр метода `where` равным `true`.

Для избежания SQL-инъекций, всегда используйте `where` с аргументами, а не включайте переменные напрямую в запрос.

Если необходимо добавить условие сравнения некоторого поля со значением, то используйте метод `key` для упрощения записи. Первым аргументом передается значение или массив значений поля, которое по умолчанию сравнивается с первичным ключем. По умолчанию поле первичного ключа установлено равным `'id'`, изменить его можно с помощью метода `pkey`. Чтобы сравнить с любым другим полем, передайте имя этого поля вторым аргументом. Аналогично методу `where`, добавляемые условия соединяются через `AND`, и существует третий аргумент или метод `orKey` для соединения условий через `OR`.

Если вам необходимо получить из базы только одну строку, а не массив строк, то используйте метод `one`. Этот метод аналогичен использованию `PDOStatement::fetch()`, но кроме этого добавляет ограничение `LIMIT 1`.

```
$row = Storage::main()
    ->table('test_table')
    ->pkey('test_table_id')
    ->fields(['test_table_id', 'field1', 'field2', 'field3'])
    ->key(123)
    ->key([1, 2, 3], 'field1')
    ->where('field2 > ? OR field3 LIKE ?', [9000, 'foo%'])
    ->one();

# SELECT test_table_id, field1, field2, field3
# FROM test_table
# WHERE test_table_id = 123 AND field1 IN (1, 2, 3) AND (field2 > 9000 OR field3 LIKE 'foo%')
# LIMIT 1

# $row = array(
#   'test_table_id' => 123,
#   'field1'        => 2,
#   'field2'        => 9001,
#   'field3'        => 'foobar'
# )
```

Существует несколько других полезных методов, позволяющих формировать SQL-запрос.

Метод `join`, с обязательным первым аргументом - имя таблицы, и тремя необязательными: условие соединения, аргументы для условия соединения, тип соединения (`LEFT`, `RIGHT`, `INNER`, `NATURAL`).

Методы `orderBy` и `addOrderBy`. Первый метод устанавливает сортировку указанную в первом аргументе на языке `SQL`. Второй метод добавляет к текущей сортировке поле указанное в первом аргументе с порядком, указанным во втором аргументе (по умолчанию `ASC`).

Метод `groupBy` соответствует `GROUP BY` в SQL.

Метод `having` добавляет условия после группировки указанные в первом аргументе. Вторым аргументом метода являются массив аргументов условия.

После использования метода `nothing`, результатом всегда будет пустой массив (для метода `all`) или `null` (для метода `one`), не зависимо от установленных условий, и запроса в БД не будет произведено.

Для ограничения выборки используются методы `limit` и `offset` соответствующие `LIMIT` и `OFFSET` в SQL. А также существует дополнительный метод `page` упрощающий постраничную разбивку результатов. Этот метод устанавливает `OFFSET` в соответствии с установленным ранее `LIMIT` и переданным в первом аргументе номером страницы, и вызывает метод `all` для получения результатов.

```
$result = Storage::main()
    ->table('test_table')
    ->addOrderBy('test_table_date', true)
    ->limit(10)
    ->page(3); # SELECT * FROM test_table ORDER BY test_table_date DESC LIMIT 10 OFFSET 20
```

После выполнения метода `all` или `one` все параметры запроса автоматически сбрасываются методом `reset`. Предусмотрено получение параметров предыдущего запроса с помощью методов начинающихся на `last`, например, `lastTable` или `lastWhere`. Аналогичным образом можно получить параметры текущего запроса, с помощью методов начинающихся на `curr`, например, `currTable` или `currWhere`.

На основе параметров предыдущего запроса, есть возможность получить полное количество записей предыдущего запроса, если вы использовали `limit`. Метод `count` выполнит запрос `SELECT COUNT (*)` использованием всех параметров предыдущего запроса.

```
$result = Storage::main()
    ->table('test_table')
    ->where('field1 like ?', ['foo%'])
    ->limit(10)
    ->page(3); # SELECT * FROM test_table WHERE field1 LIKE 'foo%' LIMIT 10 OFFSET 20

$count = Storage::main()->count(); # SELECT COUNT(*) FROM test_table WHERE field1 LIKE 'foo%'
```

Существует несколько модификаций методов `all` и `one`. Эти методы по умолчанию работают в режиме `PDO::FETCH_ASSOC`, то есть возвращают строки в виде массивов с ключами равными именам полей. Сменить режим можно передав аргументом одну из констант `PDO::FETCH_*`. Вместо этого можно воспользоваться одним из следующих методов.

Методы `allK` и `pageK` выбирают записи в режиме `PDO::FETCH_KEY_PAIR`. Это значит что выбираться должны только два поля, первое из которых будет записано в ключ результирующего массива, а второе будет соответствующим значением.

```
$colors = Storage::main()
    ->table('colors')
    ->fields(['id', 'color_title'])
    ->allK();

# $colors = array(
#   1 => 'red',
#   2 => 'green',
#   3 => 'blue',
# )
```

Метод `oneL` вернет строку в режиме `PDO::FETCH_NUM`. То есть ключами массива будут не имена полей таблицы, а номера начиная с ноля. Этот метод удобно использовать в совокупности с языковой конструкцией `list`.

```
list($first_name, $last_name, $age) = Storage::main()
    ->table('users')
    ->fields(['first_name', 'last_name', 'age'])
    ->key(123)
    ->oneL();
```

Метод `keys` можно использовать, если вам необходимо получить только массив идентификаторов, или массив соответствующий значениям только одной колонки. Этот метод устанавливает режим `PDO::FETCH_KEY_PAIR` и выбирает только поле указанное в аргументе, по умолчанию установленный первичный ключ.

```
$comment_ids = Storage::main()
    ->table('comments')
    ->where('date between ? and ?', [date('Y-m-d', time() - 60*60*24*10), date('Y-m-d')])
    ->keys();

# $comment_ids = array(
#   9001 => 9001,
#   9002 => 9002,
#   ...
#   100500 => 100500
# )
```

Класс `afw\APDO` позволяет установить обработчик результата запроса с помощью метода `handler`, аргументом которого является функция-обработчик. После выполнения запроса все добавленные функции-обработчики будут выполнены в порядке добавления. Функция-обработчик принимает аргументом массив строк результата выполнения запроса, и должна вернуть модифицированный результат выполнения запроса. Обратите внимание, что аргументом в функцию-обработчик всегда передается массив строк, как при использовании метода `all`, так и при использовании метода `one`.

```
$result = Storage::main()
    ->table('test_table')
    ->handler(function($result)
        {
            foreach ($result as &$row)
            {
                foreach ($row as &$field)
                {
                    $field = str_replace($field, 'foo', 'bar');
                }
            }
            return $result;
        }
    ->all();
```



=== Изменение данных

Чтобы добавить строки в таблицу, используйте метод `insert`. Аргументом этого метода может быть массив со значениями, ключами которого являются имена полей. Также аргументом может быть массив строк таблицы, в этом случае имена полей берутся только из первой строки, подразумевается что порядок полей во всех массивах-строках одинаковый. Метод возвращает последний идентификатор, если они генерируются автоматически.

```
# INSERT INTO test_table (field1, field2) VALUES ('foo', 'bar')
$id = Storage::main()
    ->table('test_table')
    ->insert(['field1' => 'foo', 'field2' => 'bar']);

# INSERT INTO test_table (field1, field2) VALUES ('foo', 'bar'), ('boo', 'far')
$lastId = Storage::main()
    ->table('test_table')
    ->insert([
        ['field1' => 'foo', 'field2' => 'bar'],
        ['field1' => 'boo', 'field2' => 'far']
    ]);
```

Для обновления строк таблицы используйте метод `update`. Аргументом метода является массив, ключи которого соответствуют полям таблицы. Метод возвращает `true` если обновление прошло успешно или `false` в случае возникновения ошибки. Впрочем, возвращаемое значение не понадобится, если вы используете `PDO` в режиме `PDO::ERRMODE_EXCEPTION`.

```
# UPDATE test_table SET field2 = 'bar' WHERE field1 LIKE 'foo%'
Storage::main()
    ->in('test_table')
    ->where('field1 LIKE ?', ['foo%'])
    ->update(['field2' => 'bar']);
```

Для удаления строк таблицы используйте метод `delete`.

```
# DELETE FROM test_table WHERE id = 123
Storage::main()
    ->from('test_table')
    ->key(123)
    ->delete();
```

Для удобочитаемости методов `update` и `delete` созданы синонимы метода `table`: `in` и `from`.

Для получения количества затронутых строк при обновлении или удалении, используйте метод `lastRowCount`.



=== Кэширование данных

Метод `cache` установит кэш для текущего запроса. Кэш должен реализовывать интерфейс `afw\ICache`. В данный момент существуют следующие классы реулизующие этот интерфейс: `afw\ArrayCache`, `afw\AAPC` и `afw\AMemcache`, речь о них пойдет ниже. Кэшируются как запросы целиком, так и строки по ключевым полям по отдельности.

При модификации данных с помощью методов `insert`, `update` или `delete` автоматически вызывается метод `cacheClear`, который очищает текущий установленный кэш.



=== Отладка работы с базами данных

Для получения статистической информации есть два метода: `queryCount` и `cachedCount`, возвращающих соответственно количество запросов отправленных в БД и количество запросов, результат которых был получен из кэша.

Для отладки предусмотрено использование журнала запросов, установить который можно с помощью метода `setLog`. Журнал должен реализовывать интерфейс `afw\ILog`. В фреймворке предусмотрен класс `afw\DebugLog` реализующий данный интерфейс, речь о нем будет ниже.



==#cache Кэш

Некоторые классы фреймворка, например `afw\APDO` могут использовать кэш, реализующий интерфейс `afw\ICache`, для обеспечения более высокой производительности. Этот интерфейс описывает три простые метода: `set` - сохранить в кэше данные передаваемые во втором аргументе с ключем переданным в первом аргументе, `get` - получить данные из кэша по переданному в аргументе ключу, `clear` - очистить кэш.

Самый простой вариант кэша - это обычный массив. Сохранение кэша в обычном массиве обеспечивает класс `afw\ArrayCache`. Данный кэш поможет избежать повторяющихся одинаковых запросов к БД или файлам, но только в рамках одного запуска приложения. Этот класс скорее подойдет для тестирования, чем для полноценной работы. Но при отсутствии возможности использовать другие кэши, в некоторых случаях, он тоже может принести не мало пользы.

Кэш `afw\AAPC` наследует класс [http://www.php.net/manual/en/book.apc.php `APC`], реализуя интерфейс `afw\ICache`. Кроме реализации интерфейса, этот класс имеет еще несколько простых и понятных методов, и, что не мало важно, все его методы работают с указанным в конструкторе префиксом. Кэш `APC` работает только в рамках одного запущенного процесса, это следует учитывать, если на вашем сервере может быть запущено несколько процессов PHP. В то же время каждый процесс может обрабатывать несколько приложений, поэтому каждое приложение должно использовать свой префикс в ключах кэша, чтобы избежать пересечения в именах ключей. Префикс указывается первым аргументом конструктора `afw\AAPC`, вторым аргументом передается время жизни данных в кэше, а третьим флаг отложенной чистки кэша. Отложенная очистка кэша работает следующим образом: если вы вызвали метод `clear`, то очистки кэша фактически не происходит, она выполнится в деструкторе класса `afw\AAPC`, то есть в конце работы вашего скрипта. Возможность отложенной очистки кэша предусмотрена в связи с особенностями работы класса `APC`, при больших объемах кэша очистка данных с определенным префиксом может длиться относительно долго.

Кэш `afw\AMemcache` наследует класс [http://www.php.net/manual/en/book.memcache.php `Memcache`], реализуя интерфейс `afw\ICache`. Кроме реализации интерфейса, этот класс имеет еще несколько простых методов, аналогичных классу `afw\AAPC`. Методы этого класса также работают с указанным в конструкторе префиксом. Префикс передается первым аргументом, вторым - время жизни данных. В отличие от `APC`, сервер [http://memcached.org/ `memcached`] при завершении свободной памяти начинает очищать самые старые данные, и гарантирует подобное поведение. Поэтому для очистки кэша с определенным префиксом не обязательно удалять данные из кэша, достаточно сменить префикс. Класс `afw\AMemcache` добавляет к указанному префиксу номер версии данных, этот номер тоже хранится в кэше, получается или создается в конструкторе класса и изменяется при вызове метода `clear`. По этой причине "очистка", в отличие от `afw\AAPC`, длится столько же сколько запись в кэш одной переменной. Еще одним и главным преимуществом данного кэша является то что он доступен любому приложению, которое подключится к серверу [http://memcached.org/ `memcached`].

Рекомендуется использовать фабрики для кэшей, аналогично тому как это было описано в работе с моделями и базами данных.

```
class Storage extends afw\InstanceFactory
{
    /**
     * @return afw\AAPC
     */
    static function cache()
    {
        return self::instance(__FUNCTION__, function(&$cache)
        {
            $cache = new afw\AAPC(Config::cachePrefix, Config::cacheTtl);
        });
    }
}
```



==#file Работа с файлами и изображениями

Следующий пример опишет как можно подключать обработку файлов и изображений в модели.

```
$m = new Model($db_conn, 'test_table');

# Любой файл
$m->addField('any_file')
    # фильтр только загруженных файлов
    ->file()
    # описание поля формы
    ->setFormField(Element::file('Любой файл', 'Удалить', 10000000)
        # путь сохранения файла
        ->dest('res/file/any/%s.%s');

# Текстовый
$m->addField('txt_file')
    # фильтр только текстовых файлов
    ->file('*.txt')
    ->setFormField(Element::file('Текстовый файл', 'Удалить', 10000000)
        ->dest('res/file/text/%s.txt');

# Изображение с обработкой ImageMagick
$m->addField('image1')
    # фильтр файлов изображений, по умолчанию "*.jpg;*.gif;*.png", но можно указать свои
    ->image()
    ->setFormField(Element::file('Текстовый файл', 'Удалить', 10000000)
        # Описание маленькой копии изображения
        ->dest('res/image1/small-%s.jpg')
            # обработка изображения с помощью ImageMagick
            ->imagick('-strip -quality 92 -sampling-factor 1:1 -resize 200>')
        # Описание большой копии изображения
        ->dest('res/image1/big-%s.jpg')
            ->imagick('-strip -quality 92 -sampling-factor 1:1 -resize 1000>');

# Ихображение с обработкой PHP-GD
$m->addField('image2')
    ->image()
    ->setFormField(Element::file('Текстовый файл', 'Удалить', 10000000)
        # Описание маленькой копии изображения
        ->dest('res/image2/small-%s.jpg')
            # обработка изображения с помощью PHP-GD
            ->width(200)
            ->height(200)
        # Описание большой копии изображения
        ->dest('res/image2/big-%s.jpg')
            ->width(1000)
            ->height(1000)
});
```

Как видно из примера, для сохранения файла в модели, при создании поля необходимо указание фильтра `file` или `image` и указание шаблона пути, по которому будет сохраняться файл с помощью метода `dest`.

Шаблон пути аналогичен использованию функции `printf`, первым аргументом в шаблон пути файла передается первичный ключ записи, если первичный ключ комплексный, то передаются все его составляющие отдельными аргументами, и последним аргументом передается расширение файла.

В таблице БД сохраняется только расширение файла.

Допускается указание нескольких шаблонов пути файла, и файл будет сохранен по всем указанным шаблонам, но в большинстве случаев это будет иметь смысл только для сохранения копий изображения разного формата. Для обработки изображений можно использовать метод `imagick`, аргументом которого является строка с описанием обработки изображения как у консольной программы `convert` из пакета ImageMagick. Другим способом обработки изображений является библиотека PHP-GD, для работы с которой предусмотрен ряд методов:

* `width` - ширина в пикселях;
* `height` - высота в пикселях;
* `background` - установка фона в формате FFFFFF;
* `quality` - установка качества изображения (0 - 100 для JPEG, 0 - 9 для PNG);
* `reduction` - принцип уменьшения изображения, используются константы `afw\File::REDUCTION_*`:
** `afw\File::REDUCTION_PROPORTIONAL` - изображение вписывается в прямоугольник с указанной шириной и высотой сохраняя пропорции;
** `afw\File::REDUCTION_UNPROPORTIONAL` - изображение вписывается в прямоугольник с указанной шириной и высотой без сохранения пропорций;
** `afw\File::REDUCTION_CENTER` - изображение максимально заполняет прямоугольник с указанной шириной и высотой, сохраняя пропорции, не влезающие края обрезаются;
** `afw\File::REDUCTION_BEGIN` - изображение максимально заполняет прямоугольник с указанной шириной и высотой, сохраняя пропорции, не влезающий правый или нижний край обрезается;
** `afw\File::REDUCTION_END` - изображение максимально заполняет прямоугольник с указанной шириной и высотой, сохраняя пропорции, не влезающий левый или верхний край обрезается;
* `watermark` - путь к изображению водяного знака;
* `wm_width` - ширина водяного знака, допустимо указывать в пикселях или в процентах со знаком "%";
* `wm_height` - высота водяного знака, допустимо указывать в пикселях или в процентах со знаком "%";
* `wm_left` - отступ водяного знака слева от края изображения, допустимо указывать в пикселях или в процентах со знаком "%";
* `wm_top` - отступ водяного знака справа от края изображения, допустимо указывать в пикселях или в процентах со знаком "%";
* `format` - формат сохраняемого изображения, по умолчанию используется расширение файла, но можно указать принудительно, например если расширения нет, используются константы `afw\File::FORMAT_*`:
** `afw\File::FORMAT_JPEG` - формат JPEG;
** `afw\File::FORMAT_GIF` - формат GIF;
** `afw\File::FORMAT_PNG` - формат PNG;
** `afw\File::FORMAT_ORIGINAL` - сохраняется формат исходного изображения.

Если вы хотите сохранить изображение не через форму, а напрямую, достаточно передать данные изображения в метод `insert` или `update` в том же формате как PHP передает данные о загруженных файлах в массиве `$_FILES`. Модель будет использовать только параметры `name`, для получения расширения исходного файла, и `tmp_name` для получения пути файла, который необходимо сохранить.

Теперь, чтобы получить путь к сохраненному файлу, можно использовать метод `dest` у модели. Первым аргументом этого метода указывается имя поля, вторым - массив данных соответствующий одной строке таблицы БД, третьим аргументом передается номер связанного с этим полем изображения. Нумерация ведется в порядке добавления описаний изображений к модели и начинается с нуля. Третий аргумент не обязательный, по умолчанию используется номер 0, соответствующий первому объявленному изображению. Продолжим предыдущий пример.

```
$rows = $m->db()
    ->limit(10)
    ->page(1);

foreach ($rows as $row)
{
    # по умолчанию используется первое определенное изображение
    echo $m->dest('image1', $row); # res/image1/small-123.jpg

    # другие изображения можно получить указывая номер (начиная с 0)
    echo $m->dest('image1', $row, 1); # res/image1/big-123.jpg
}
```

Обратите внимание что возвращаемый путь к изображению относительный, при использовании его в шаблонах вероятнее всего вам нужно будет добавлять слэш, чтобы пути к изобрадениям были относительно корня сайта.

```
<?php foreach ($this->photos as $photo): ?>
    <a href="/<?= M::photo()->dest('image', $photo, 1) ?>">
        <img
            src="/<?= M::photo()->dest('image', $photo) ?>"
            alt="<?= htmlspecialchars($photo['title']) ?>"
         />
    </a>
<?php endforeach ?>
```



==#utils Утилиты

===#utilDebugLog Вывод отладочной информации

Для сбора и вывода отладочной информации предусмотрен класс `afw\DebugLog`. Конструктор этого класса принимает первым аргументом время запуска скрипта в формате функции `microtime (true)`, на случай если экземпляр класса `afw\DebugLog` создается не в самом начале запуска скрипта. Класс может выводить информацию разными способами, активировать которые можно с помощью следующих свойств калсса:
* `jsConsole` - вывод в консоль javascript в браузере с помощью функции `console.log`;
* `phpLog` - вывод в стандартный вывод ошибок PHP с помощью функции `error_log`;
* `textOutput` - используется стандартный вывод с помощью `echo`;
* `echo` - так же как и у предыдущего способа используется стандартный вывод с помощью `echo`, но вывод производится сразу в момент добавления записи в лог, в то время как у других способов вывод производится только при вызове метода `flush` или в конце работы скрипта.

Для добавления записи в лог используется метод `add`. Также доступны методы `printf` и `print_r` работающих аналогично одноименным функциям PHP.

Свойство `enabled` включает или выключает работу лога. По умолчанию лог выключен.

Класс `afw\DebugLog` реализует интерфейс `ArrayAccess`, и вместо использования метода `add` можно добавить запись в лог так же как добавляются элементы в массив.

Метод `resources` добавляет в лог информацию об используемых в данный момент ресурсах. Аргументом функции является произвольная строка, по которой вы сможете найти запись в логе. Этот метод выводит в лог следующую информацию:
* `point` - время от начала работы скрипта и используемая в данный момент оперативная память;
* `interval` - время и изменение использования оперативной памяти от предыдущего вызова метода `resources` или от начала работы скрипта, если это первый вызов;
* `peak` - пиковое использование оперативной памяти.

Для работы с логом рекомендуется использовать фабрику `afw\InstanceFactory`.

Класс `afw\APDO` умеет журналировать запросы с помощью `afw\DebugLog`. Для этого необходимо установить лог с помощью метода `setLog`.

```
global $scriptStart;
$scriptStart = microtime(true);

class Utils extends afw\InstanceFactory
{
    /**
     * @return afw\DebugLog
     */
    static function log()
    {
        return self::instance(__FUNCTION__, function(&$log)
        {
            global $scriptStart;
            $log = new afw\DebugLog($scriptStart);
            $log->enabled   = true;
            $log->jsConsole = true;
            $log->phpLog    = true;
        });
    }
}

Utils::log()->resources('start');

$result = Storage::main()
    ->from('test_table')
    ->limit(10)
    ->all();

Utils::log()->resources('select');
Utils::log()->print_r($result);

var_dump($result);

Utils::log()->resources('finish');
```



===#utilSession Сессии

Для упрощения работы с сессиями есть класс `afw\Session`. Используя его, вам не нужно задумываться была ли инициализована сессия ранее, а также сессия будет открываться только когда это действительно нужно. Класс имеет ряд статических методов:
* `read` - открывает и сразу же закрывает сессию, но только при наличии куки сессии. Если соответствующей куки не установлено, то сессия не открывается. Таким образом, сессия будет прочитана, только если она существует. После вызова этого метода у вас будет доступ к переменным сессии. Если вы храните сессии в файлах, то файл сессии не будет заблокирован. Если переменные сессии были прочитаны ранее, то этот метод ничего не делает.
* `start` - открывает сессию для записи. Если ранее сессия была открыта, но не закрыта, то этот метод ничего не делает. Если сессии хранятся в файлах, то файл сессии блокируется.
* `commit` - сохраняет и закрывает сессию. Закрытие сессии произойдет, только когда этот метод будет вызван столько раз, сколько раз сессия была открыта ранее с помощью метода `start`.
* `get` - читает переменную сессии. Перед попыткой получения переменной, этот метод вызывает `read`, поэтому для получения переменных сессии с помощью этого метода, вызывать `read` отдельно не нужно.
* `set` - устанавливает переменную сессии. Этот метод автоматически вызывает `start` и `commit`, поэтому вам не нужно вызывать их отдельно, если вы устанавливаете только одну переменную. Однако, если вам необходимо установить несколько переменных подряд, будет предпочтительней вызвать `start` перед установкой переменных и `commit` после, таким образом сессия будет открыта и записана только один раз, а не при каждом вызове метода `set`.
* `destroy` - уничтожает сессию и все ее данные.

```
use afw\Session;

echo Session::get('foo');

Session::start();
Session::set('bar', 123);
Session::set('boo', 'asd');
Session::commit();

var_dump($_SESSION);
```

Глобальная переменная `$_SESSION` также доступна, после того как хотябы один раз был прямо или косвенно вызван метод `read` или `start`.
